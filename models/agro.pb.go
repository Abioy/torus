// Code generated by protoc-gen-gogo.
// source: agro.proto
// DO NOT EDIT!

/*
	Package models is a generated protocol buffer package.

	It is generated from these files:
		agro.proto
		rpc.proto

	It has these top-level messages:
		Metadata
		INode
		BlockLayer
		Directory
		Volume
		FileEntry
		FileChainSet
		PeerInfo
		Ring
		BlockRef
		INodeRef
		BlockRequest
		BlockResponse
		PutBlockRequest
		PutResponse
		RebalanceCheckRequest
		RebalanceCheckResponse
*/
package models

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Volume_VolumeType int32

const (
	Volume_FILE  Volume_VolumeType = 0
	Volume_BLOCK Volume_VolumeType = 1
)

var Volume_VolumeType_name = map[int32]string{
	0: "FILE",
	1: "BLOCK",
}
var Volume_VolumeType_value = map[string]int32{
	"FILE":  0,
	"BLOCK": 1,
}

func (x Volume_VolumeType) String() string {
	return proto.EnumName(Volume_VolumeType_name, int32(x))
}

type Metadata struct {
	Uid   uint32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Gid   uint32 `protobuf:"varint,2,opt,name=gid,proto3" json:"gid,omitempty"`
	Mode  uint32 `protobuf:"varint,3,opt,name=mode,proto3" json:"mode,omitempty"`
	Flags uint32 `protobuf:"varint,4,opt,name=flags,proto3" json:"flags,omitempty"`
	Ctime uint64 `protobuf:"varint,5,opt,name=ctime,proto3" json:"ctime,omitempty"`
	Mtime uint64 `protobuf:"varint,6,opt,name=mtime,proto3" json:"mtime,omitempty"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}

type INode struct {
	Volume      uint64            `protobuf:"varint,1,opt,name=volume,proto3" json:"volume,omitempty"`
	INode       uint64            `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
	Chain       uint64            `protobuf:"varint,3,opt,name=chain,proto3" json:"chain,omitempty"`
	Filesize    uint64            `protobuf:"varint,4,opt,name=filesize,proto3" json:"filesize,omitempty"`
	Filenames   []string          `protobuf:"bytes,5,rep,name=filenames" json:"filenames,omitempty"`
	Permissions *Metadata         `protobuf:"bytes,6,opt,name=permissions" json:"permissions,omitempty"`
	Attrs       map[string]string `protobuf:"bytes,7,rep,name=attrs" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Blocks      []*BlockLayer     `protobuf:"bytes,8,rep,name=blocks" json:"blocks,omitempty"`
}

func (m *INode) Reset()         { *m = INode{} }
func (m *INode) String() string { return proto.CompactTextString(m) }
func (*INode) ProtoMessage()    {}

func (m *INode) GetPermissions() *Metadata {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *INode) GetAttrs() map[string]string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *INode) GetBlocks() []*BlockLayer {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type BlockLayer struct {
	Type    uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *BlockLayer) Reset()         { *m = BlockLayer{} }
func (m *BlockLayer) String() string { return proto.CompactTextString(m) }
func (*BlockLayer) ProtoMessage()    {}

type Directory struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// key is the filename without the path
	Files map[string]*FileEntry `protobuf:"bytes,2,rep,name=files" json:"files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Directory) Reset()         { *m = Directory{} }
func (m *Directory) String() string { return proto.CompactTextString(m) }
func (*Directory) ProtoMessage()    {}

func (m *Directory) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Directory) GetFiles() map[string]*FileEntry {
	if m != nil {
		return m.Files
	}
	return nil
}

type Volume struct {
	Name string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id   uint64            `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Type Volume_VolumeType `protobuf:"varint,3,opt,name=type,proto3,enum=models.Volume_VolumeType" json:"type,omitempty"`
	// TODO(barakmich): Respect sizes for FILE volumes.
	MaxBytes uint64 `protobuf:"varint,4,opt,name=max_bytes,proto3" json:"max_bytes,omitempty"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}

type FileEntry struct {
	Chain   uint64 `protobuf:"varint,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Sympath string `protobuf:"bytes,2,opt,name=sympath,proto3" json:"sympath,omitempty"`
}

func (m *FileEntry) Reset()         { *m = FileEntry{} }
func (m *FileEntry) String() string { return proto.CompactTextString(m) }
func (*FileEntry) ProtoMessage()    {}

type FileChainSet struct {
	Chains map[uint64]uint64 `protobuf:"bytes,1,rep,name=chains" json:"chains,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *FileChainSet) Reset()         { *m = FileChainSet{} }
func (m *FileChainSet) String() string { return proto.CompactTextString(m) }
func (*FileChainSet) ProtoMessage()    {}

func (m *FileChainSet) GetChains() map[uint64]uint64 {
	if m != nil {
		return m.Chains
	}
	return nil
}

type PeerInfo struct {
	UUID                string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Address             string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	LastSeen            int64  `protobuf:"varint,3,opt,name=last_seen,proto3" json:"last_seen,omitempty"`
	TotalBlocks         uint64 `protobuf:"varint,4,opt,name=total_blocks,proto3" json:"total_blocks,omitempty"`
	UsedBlocks          uint64 `protobuf:"varint,5,opt,name=used_blocks,proto3" json:"used_blocks,omitempty"`
	LastRebalanceFinish int64  `protobuf:"varint,6,opt,name=last_rebalance_finish,proto3" json:"last_rebalance_finish,omitempty"`
	LastRebalanceBlocks uint64 `protobuf:"varint,7,opt,name=last_rebalance_blocks,proto3" json:"last_rebalance_blocks,omitempty"`
	Rebalancing         bool   `protobuf:"varint,8,opt,name=rebalancing,proto3" json:"rebalancing,omitempty"`
	TimedOut            bool   `protobuf:"varint,9,opt,name=timed_out,proto3" json:"timed_out,omitempty"`
}

func (m *PeerInfo) Reset()         { *m = PeerInfo{} }
func (m *PeerInfo) String() string { return proto.CompactTextString(m) }
func (*PeerInfo) ProtoMessage()    {}

type Ring struct {
	Type              uint32            `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Version           uint32            `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	ReplicationFactor uint32            `protobuf:"varint,3,opt,name=replication_factor,proto3" json:"replication_factor,omitempty"`
	Peers             []*PeerInfo       `protobuf:"bytes,4,rep,name=peers" json:"peers,omitempty"`
	Attrs             map[string][]byte `protobuf:"bytes,5,rep,name=attrs" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Ring) Reset()         { *m = Ring{} }
func (m *Ring) String() string { return proto.CompactTextString(m) }
func (*Ring) ProtoMessage()    {}

func (m *Ring) GetPeers() []*PeerInfo {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *Ring) GetAttrs() map[string][]byte {
	if m != nil {
		return m.Attrs
	}
	return nil
}

type BlockRef struct {
	Volume uint64 `protobuf:"varint,1,opt,name=volume,proto3" json:"volume,omitempty"`
	INode  uint64 `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
	Block  uint64 `protobuf:"varint,3,opt,name=block,proto3" json:"block,omitempty"`
}

func (m *BlockRef) Reset()         { *m = BlockRef{} }
func (m *BlockRef) String() string { return proto.CompactTextString(m) }
func (*BlockRef) ProtoMessage()    {}

type INodeRef struct {
	Volume uint64 `protobuf:"varint,1,opt,name=volume,proto3" json:"volume,omitempty"`
	INode  uint64 `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
}

func (m *INodeRef) Reset()         { *m = INodeRef{} }
func (m *INodeRef) String() string { return proto.CompactTextString(m) }
func (*INodeRef) ProtoMessage()    {}

func init() {
	proto.RegisterType((*Metadata)(nil), "models.Metadata")
	proto.RegisterType((*INode)(nil), "models.INode")
	proto.RegisterType((*BlockLayer)(nil), "models.BlockLayer")
	proto.RegisterType((*Directory)(nil), "models.Directory")
	proto.RegisterType((*Volume)(nil), "models.Volume")
	proto.RegisterType((*FileEntry)(nil), "models.FileEntry")
	proto.RegisterType((*FileChainSet)(nil), "models.FileChainSet")
	proto.RegisterType((*PeerInfo)(nil), "models.PeerInfo")
	proto.RegisterType((*Ring)(nil), "models.Ring")
	proto.RegisterType((*BlockRef)(nil), "models.BlockRef")
	proto.RegisterType((*INodeRef)(nil), "models.INodeRef")
	proto.RegisterEnum("models.Volume_VolumeType", Volume_VolumeType_name, Volume_VolumeType_value)
}
func (this *Metadata) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Metadata)
	if !ok {
		that2, ok := that.(Metadata)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Metadata")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Metadata but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Metadata but is not nil && this == nil")
	}
	if this.Uid != that1.Uid {
		return fmt.Errorf("Uid this(%v) Not Equal that(%v)", this.Uid, that1.Uid)
	}
	if this.Gid != that1.Gid {
		return fmt.Errorf("Gid this(%v) Not Equal that(%v)", this.Gid, that1.Gid)
	}
	if this.Mode != that1.Mode {
		return fmt.Errorf("Mode this(%v) Not Equal that(%v)", this.Mode, that1.Mode)
	}
	if this.Flags != that1.Flags {
		return fmt.Errorf("Flags this(%v) Not Equal that(%v)", this.Flags, that1.Flags)
	}
	if this.Ctime != that1.Ctime {
		return fmt.Errorf("Ctime this(%v) Not Equal that(%v)", this.Ctime, that1.Ctime)
	}
	if this.Mtime != that1.Mtime {
		return fmt.Errorf("Mtime this(%v) Not Equal that(%v)", this.Mtime, that1.Mtime)
	}
	return nil
}
func (this *Metadata) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Metadata)
	if !ok {
		that2, ok := that.(Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Gid != that1.Gid {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if this.Ctime != that1.Ctime {
		return false
	}
	if this.Mtime != that1.Mtime {
		return false
	}
	return true
}
func (this *INode) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*INode)
	if !ok {
		that2, ok := that.(INode)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *INode")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *INode but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *INode but is not nil && this == nil")
	}
	if this.Volume != that1.Volume {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if this.INode != that1.INode {
		return fmt.Errorf("INode this(%v) Not Equal that(%v)", this.INode, that1.INode)
	}
	if this.Chain != that1.Chain {
		return fmt.Errorf("Chain this(%v) Not Equal that(%v)", this.Chain, that1.Chain)
	}
	if this.Filesize != that1.Filesize {
		return fmt.Errorf("Filesize this(%v) Not Equal that(%v)", this.Filesize, that1.Filesize)
	}
	if len(this.Filenames) != len(that1.Filenames) {
		return fmt.Errorf("Filenames this(%v) Not Equal that(%v)", len(this.Filenames), len(that1.Filenames))
	}
	for i := range this.Filenames {
		if this.Filenames[i] != that1.Filenames[i] {
			return fmt.Errorf("Filenames this[%v](%v) Not Equal that[%v](%v)", i, this.Filenames[i], i, that1.Filenames[i])
		}
	}
	if !this.Permissions.Equal(that1.Permissions) {
		return fmt.Errorf("Permissions this(%v) Not Equal that(%v)", this.Permissions, that1.Permissions)
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return fmt.Errorf("Attrs this(%v) Not Equal that(%v)", len(this.Attrs), len(that1.Attrs))
	}
	for i := range this.Attrs {
		if this.Attrs[i] != that1.Attrs[i] {
			return fmt.Errorf("Attrs this[%v](%v) Not Equal that[%v](%v)", i, this.Attrs[i], i, that1.Attrs[i])
		}
	}
	if len(this.Blocks) != len(that1.Blocks) {
		return fmt.Errorf("Blocks this(%v) Not Equal that(%v)", len(this.Blocks), len(that1.Blocks))
	}
	for i := range this.Blocks {
		if !this.Blocks[i].Equal(that1.Blocks[i]) {
			return fmt.Errorf("Blocks this[%v](%v) Not Equal that[%v](%v)", i, this.Blocks[i], i, that1.Blocks[i])
		}
	}
	return nil
}
func (this *INode) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*INode)
	if !ok {
		that2, ok := that.(INode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.INode != that1.INode {
		return false
	}
	if this.Chain != that1.Chain {
		return false
	}
	if this.Filesize != that1.Filesize {
		return false
	}
	if len(this.Filenames) != len(that1.Filenames) {
		return false
	}
	for i := range this.Filenames {
		if this.Filenames[i] != that1.Filenames[i] {
			return false
		}
	}
	if !this.Permissions.Equal(that1.Permissions) {
		return false
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if this.Attrs[i] != that1.Attrs[i] {
			return false
		}
	}
	if len(this.Blocks) != len(that1.Blocks) {
		return false
	}
	for i := range this.Blocks {
		if !this.Blocks[i].Equal(that1.Blocks[i]) {
			return false
		}
	}
	return true
}
func (this *BlockLayer) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*BlockLayer)
	if !ok {
		that2, ok := that.(BlockLayer)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *BlockLayer")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *BlockLayer but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *BlockLayer but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return fmt.Errorf("Content this(%v) Not Equal that(%v)", this.Content, that1.Content)
	}
	return nil
}
func (this *BlockLayer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BlockLayer)
	if !ok {
		that2, ok := that.(BlockLayer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	return true
}
func (this *Directory) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Directory)
	if !ok {
		that2, ok := that.(Directory)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Directory")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Directory but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Directory but is not nil && this == nil")
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return fmt.Errorf("Metadata this(%v) Not Equal that(%v)", this.Metadata, that1.Metadata)
	}
	if len(this.Files) != len(that1.Files) {
		return fmt.Errorf("Files this(%v) Not Equal that(%v)", len(this.Files), len(that1.Files))
	}
	for i := range this.Files {
		if !this.Files[i].Equal(that1.Files[i]) {
			return fmt.Errorf("Files this[%v](%v) Not Equal that[%v](%v)", i, this.Files[i], i, that1.Files[i])
		}
	}
	return nil
}
func (this *Directory) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Directory)
	if !ok {
		that2, ok := that.(Directory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if len(this.Files) != len(that1.Files) {
		return false
	}
	for i := range this.Files {
		if !this.Files[i].Equal(that1.Files[i]) {
			return false
		}
	}
	return true
}
func (this *Volume) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Volume)
	if !ok {
		that2, ok := that.(Volume)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Volume")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Volume but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Volume but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.MaxBytes != that1.MaxBytes {
		return fmt.Errorf("MaxBytes this(%v) Not Equal that(%v)", this.MaxBytes, that1.MaxBytes)
	}
	return nil
}
func (this *Volume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Volume)
	if !ok {
		that2, ok := that.(Volume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.MaxBytes != that1.MaxBytes {
		return false
	}
	return true
}
func (this *FileEntry) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FileEntry)
	if !ok {
		that2, ok := that.(FileEntry)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FileEntry")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FileEntry but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FileEntry but is not nil && this == nil")
	}
	if this.Chain != that1.Chain {
		return fmt.Errorf("Chain this(%v) Not Equal that(%v)", this.Chain, that1.Chain)
	}
	if this.Sympath != that1.Sympath {
		return fmt.Errorf("Sympath this(%v) Not Equal that(%v)", this.Sympath, that1.Sympath)
	}
	return nil
}
func (this *FileEntry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FileEntry)
	if !ok {
		that2, ok := that.(FileEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Chain != that1.Chain {
		return false
	}
	if this.Sympath != that1.Sympath {
		return false
	}
	return true
}
func (this *FileChainSet) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FileChainSet)
	if !ok {
		that2, ok := that.(FileChainSet)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FileChainSet")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FileChainSet but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FileChainSet but is not nil && this == nil")
	}
	if len(this.Chains) != len(that1.Chains) {
		return fmt.Errorf("Chains this(%v) Not Equal that(%v)", len(this.Chains), len(that1.Chains))
	}
	for i := range this.Chains {
		if this.Chains[i] != that1.Chains[i] {
			return fmt.Errorf("Chains this[%v](%v) Not Equal that[%v](%v)", i, this.Chains[i], i, that1.Chains[i])
		}
	}
	return nil
}
func (this *FileChainSet) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FileChainSet)
	if !ok {
		that2, ok := that.(FileChainSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Chains) != len(that1.Chains) {
		return false
	}
	for i := range this.Chains {
		if this.Chains[i] != that1.Chains[i] {
			return false
		}
	}
	return true
}
func (this *PeerInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PeerInfo)
	if !ok {
		that2, ok := that.(PeerInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PeerInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PeerInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PeerInfo but is not nil && this == nil")
	}
	if this.UUID != that1.UUID {
		return fmt.Errorf("UUID this(%v) Not Equal that(%v)", this.UUID, that1.UUID)
	}
	if this.Address != that1.Address {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if this.LastSeen != that1.LastSeen {
		return fmt.Errorf("LastSeen this(%v) Not Equal that(%v)", this.LastSeen, that1.LastSeen)
	}
	if this.TotalBlocks != that1.TotalBlocks {
		return fmt.Errorf("TotalBlocks this(%v) Not Equal that(%v)", this.TotalBlocks, that1.TotalBlocks)
	}
	if this.UsedBlocks != that1.UsedBlocks {
		return fmt.Errorf("UsedBlocks this(%v) Not Equal that(%v)", this.UsedBlocks, that1.UsedBlocks)
	}
	if this.LastRebalanceFinish != that1.LastRebalanceFinish {
		return fmt.Errorf("LastRebalanceFinish this(%v) Not Equal that(%v)", this.LastRebalanceFinish, that1.LastRebalanceFinish)
	}
	if this.LastRebalanceBlocks != that1.LastRebalanceBlocks {
		return fmt.Errorf("LastRebalanceBlocks this(%v) Not Equal that(%v)", this.LastRebalanceBlocks, that1.LastRebalanceBlocks)
	}
	if this.Rebalancing != that1.Rebalancing {
		return fmt.Errorf("Rebalancing this(%v) Not Equal that(%v)", this.Rebalancing, that1.Rebalancing)
	}
	if this.TimedOut != that1.TimedOut {
		return fmt.Errorf("TimedOut this(%v) Not Equal that(%v)", this.TimedOut, that1.TimedOut)
	}
	return nil
}
func (this *PeerInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PeerInfo)
	if !ok {
		that2, ok := that.(PeerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.UUID != that1.UUID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.LastSeen != that1.LastSeen {
		return false
	}
	if this.TotalBlocks != that1.TotalBlocks {
		return false
	}
	if this.UsedBlocks != that1.UsedBlocks {
		return false
	}
	if this.LastRebalanceFinish != that1.LastRebalanceFinish {
		return false
	}
	if this.LastRebalanceBlocks != that1.LastRebalanceBlocks {
		return false
	}
	if this.Rebalancing != that1.Rebalancing {
		return false
	}
	if this.TimedOut != that1.TimedOut {
		return false
	}
	return true
}
func (this *Ring) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Ring)
	if !ok {
		that2, ok := that.(Ring)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Ring")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Ring but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Ring but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return fmt.Errorf("ReplicationFactor this(%v) Not Equal that(%v)", this.ReplicationFactor, that1.ReplicationFactor)
	}
	if len(this.Peers) != len(that1.Peers) {
		return fmt.Errorf("Peers this(%v) Not Equal that(%v)", len(this.Peers), len(that1.Peers))
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return fmt.Errorf("Peers this[%v](%v) Not Equal that[%v](%v)", i, this.Peers[i], i, that1.Peers[i])
		}
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return fmt.Errorf("Attrs this(%v) Not Equal that(%v)", len(this.Attrs), len(that1.Attrs))
	}
	for i := range this.Attrs {
		if !bytes.Equal(this.Attrs[i], that1.Attrs[i]) {
			return fmt.Errorf("Attrs this[%v](%v) Not Equal that[%v](%v)", i, this.Attrs[i], i, that1.Attrs[i])
		}
	}
	return nil
}
func (this *Ring) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Ring)
	if !ok {
		that2, ok := that.(Ring)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if len(this.Peers) != len(that1.Peers) {
		return false
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return false
		}
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if !bytes.Equal(this.Attrs[i], that1.Attrs[i]) {
			return false
		}
	}
	return true
}
func (this *BlockRef) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*BlockRef)
	if !ok {
		that2, ok := that.(BlockRef)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *BlockRef")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *BlockRef but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *BlockRef but is not nil && this == nil")
	}
	if this.Volume != that1.Volume {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if this.INode != that1.INode {
		return fmt.Errorf("INode this(%v) Not Equal that(%v)", this.INode, that1.INode)
	}
	if this.Block != that1.Block {
		return fmt.Errorf("Block this(%v) Not Equal that(%v)", this.Block, that1.Block)
	}
	return nil
}
func (this *BlockRef) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BlockRef)
	if !ok {
		that2, ok := that.(BlockRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.INode != that1.INode {
		return false
	}
	if this.Block != that1.Block {
		return false
	}
	return true
}
func (this *INodeRef) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*INodeRef)
	if !ok {
		that2, ok := that.(INodeRef)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *INodeRef")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *INodeRef but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *INodeRef but is not nil && this == nil")
	}
	if this.Volume != that1.Volume {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if this.INode != that1.INode {
		return fmt.Errorf("INode this(%v) Not Equal that(%v)", this.INode, that1.INode)
	}
	return nil
}
func (this *INodeRef) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*INodeRef)
	if !ok {
		that2, ok := that.(INodeRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.INode != that1.INode {
		return false
	}
	return true
}
func (m *Metadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Metadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Uid))
	}
	if m.Gid != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.Gid))
	}
	if m.Mode != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.Mode))
	}
	if m.Flags != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgro(data, i, uint64(m.Flags))
	}
	if m.Ctime != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgro(data, i, uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgro(data, i, uint64(m.Mtime))
	}
	return i, nil
}

func (m *INode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *INode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Volume != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Volume))
	}
	if m.INode != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.INode))
	}
	if m.Chain != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.Chain))
	}
	if m.Filesize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgro(data, i, uint64(m.Filesize))
	}
	if len(m.Filenames) > 0 {
		for _, s := range m.Filenames {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Permissions != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgro(data, i, uint64(m.Permissions.Size()))
		n1, err := m.Permissions.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Attrs) > 0 {
		for k, _ := range m.Attrs {
			data[i] = 0x3a
			i++
			v := m.Attrs[k]
			mapSize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + len(v) + sovAgro(uint64(len(v)))
			i = encodeVarintAgro(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgro(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAgro(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			data[i] = 0x42
			i++
			i = encodeVarintAgro(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BlockLayer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BlockLayer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Type))
	}
	if m.Content != nil {
		if len(m.Content) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintAgro(data, i, uint64(len(m.Content)))
			i += copy(data[i:], m.Content)
		}
	}
	return i, nil
}

func (m *Directory) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Directory) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgro(data, i, uint64(m.Metadata.Size()))
		n2, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Files) > 0 {
		for k, _ := range m.Files {
			data[i] = 0x12
			i++
			v := m.Files[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + msgSize + sovAgro(uint64(msgSize))
			i = encodeVarintAgro(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgro(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAgro(data, i, uint64(v.Size()))
			n3, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n3
		}
	}
	return i, nil
}

func (m *Volume) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Volume) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgro(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Id != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.Id))
	}
	if m.Type != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.Type))
	}
	if m.MaxBytes != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgro(data, i, uint64(m.MaxBytes))
	}
	return i, nil
}

func (m *FileEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chain != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Chain))
	}
	if len(m.Sympath) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgro(data, i, uint64(len(m.Sympath)))
		i += copy(data[i:], m.Sympath)
	}
	return i, nil
}

func (m *FileChainSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileChainSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chains) > 0 {
		for k, _ := range m.Chains {
			data[i] = 0xa
			i++
			v := m.Chains[k]
			mapSize := 1 + sovAgro(uint64(k)) + 1 + sovAgro(uint64(v))
			i = encodeVarintAgro(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintAgro(data, i, uint64(k))
			data[i] = 0x10
			i++
			i = encodeVarintAgro(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *PeerInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PeerInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UUID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgro(data, i, uint64(len(m.UUID)))
		i += copy(data[i:], m.UUID)
	}
	if len(m.Address) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgro(data, i, uint64(len(m.Address)))
		i += copy(data[i:], m.Address)
	}
	if m.LastSeen != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.LastSeen))
	}
	if m.TotalBlocks != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgro(data, i, uint64(m.TotalBlocks))
	}
	if m.UsedBlocks != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgro(data, i, uint64(m.UsedBlocks))
	}
	if m.LastRebalanceFinish != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgro(data, i, uint64(m.LastRebalanceFinish))
	}
	if m.LastRebalanceBlocks != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgro(data, i, uint64(m.LastRebalanceBlocks))
	}
	if m.Rebalancing {
		data[i] = 0x40
		i++
		if m.Rebalancing {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.TimedOut {
		data[i] = 0x48
		i++
		if m.TimedOut {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Ring) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Ring) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Type))
	}
	if m.Version != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.Version))
	}
	if m.ReplicationFactor != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.ReplicationFactor))
	}
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			data[i] = 0x22
			i++
			i = encodeVarintAgro(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attrs) > 0 {
		for k, _ := range m.Attrs {
			data[i] = 0x2a
			i++
			v := m.Attrs[k]
			mapSize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + len(v) + sovAgro(uint64(len(v)))
			i = encodeVarintAgro(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgro(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAgro(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *BlockRef) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BlockRef) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Volume != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Volume))
	}
	if m.INode != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.INode))
	}
	if m.Block != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.Block))
	}
	return i, nil
}

func (m *INodeRef) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *INodeRef) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Volume != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Volume))
	}
	if m.INode != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.INode))
	}
	return i, nil
}

func encodeFixed64Agro(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Agro(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAgro(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedMetadata(r randyAgro, easy bool) *Metadata {
	this := &Metadata{}
	this.Uid = uint32(r.Uint32())
	this.Gid = uint32(r.Uint32())
	this.Mode = uint32(r.Uint32())
	this.Flags = uint32(r.Uint32())
	this.Ctime = uint64(uint64(r.Uint32()))
	this.Mtime = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedINode(r randyAgro, easy bool) *INode {
	this := &INode{}
	this.Volume = uint64(uint64(r.Uint32()))
	this.INode = uint64(uint64(r.Uint32()))
	this.Chain = uint64(uint64(r.Uint32()))
	this.Filesize = uint64(uint64(r.Uint32()))
	v1 := r.Intn(10)
	this.Filenames = make([]string, v1)
	for i := 0; i < v1; i++ {
		this.Filenames[i] = randStringAgro(r)
	}
	if r.Intn(10) != 0 {
		this.Permissions = NewPopulatedMetadata(r, easy)
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(10)
		this.Attrs = make(map[string]string)
		for i := 0; i < v2; i++ {
			this.Attrs[randStringAgro(r)] = randStringAgro(r)
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Blocks = make([]*BlockLayer, v3)
		for i := 0; i < v3; i++ {
			this.Blocks[i] = NewPopulatedBlockLayer(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBlockLayer(r randyAgro, easy bool) *BlockLayer {
	this := &BlockLayer{}
	this.Type = uint32(r.Uint32())
	v4 := r.Intn(100)
	this.Content = make([]byte, v4)
	for i := 0; i < v4; i++ {
		this.Content[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDirectory(r randyAgro, easy bool) *Directory {
	this := &Directory{}
	if r.Intn(10) != 0 {
		this.Metadata = NewPopulatedMetadata(r, easy)
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.Files = make(map[string]*FileEntry)
		for i := 0; i < v5; i++ {
			this.Files[randStringAgro(r)] = NewPopulatedFileEntry(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolume(r randyAgro, easy bool) *Volume {
	this := &Volume{}
	this.Name = randStringAgro(r)
	this.Id = uint64(uint64(r.Uint32()))
	this.Type = Volume_VolumeType([]int32{0, 1}[r.Intn(2)])
	this.MaxBytes = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFileEntry(r randyAgro, easy bool) *FileEntry {
	this := &FileEntry{}
	this.Chain = uint64(uint64(r.Uint32()))
	this.Sympath = randStringAgro(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFileChainSet(r randyAgro, easy bool) *FileChainSet {
	this := &FileChainSet{}
	if r.Intn(10) != 0 {
		v6 := r.Intn(10)
		this.Chains = make(map[uint64]uint64)
		for i := 0; i < v6; i++ {
			v7 := uint64(uint64(r.Uint32()))
			this.Chains[v7] = uint64(uint64(r.Uint32()))
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPeerInfo(r randyAgro, easy bool) *PeerInfo {
	this := &PeerInfo{}
	this.UUID = randStringAgro(r)
	this.Address = randStringAgro(r)
	this.LastSeen = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastSeen *= -1
	}
	this.TotalBlocks = uint64(uint64(r.Uint32()))
	this.UsedBlocks = uint64(uint64(r.Uint32()))
	this.LastRebalanceFinish = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastRebalanceFinish *= -1
	}
	this.LastRebalanceBlocks = uint64(uint64(r.Uint32()))
	this.Rebalancing = bool(bool(r.Intn(2) == 0))
	this.TimedOut = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRing(r randyAgro, easy bool) *Ring {
	this := &Ring{}
	this.Type = uint32(r.Uint32())
	this.Version = uint32(r.Uint32())
	this.ReplicationFactor = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Peers = make([]*PeerInfo, v8)
		for i := 0; i < v8; i++ {
			this.Peers[i] = NewPopulatedPeerInfo(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(10)
		this.Attrs = make(map[string][]byte)
		for i := 0; i < v9; i++ {
			v10 := r.Intn(100)
			v11 := randStringAgro(r)
			this.Attrs[v11] = make([]byte, v10)
			for i := 0; i < v10; i++ {
				this.Attrs[v11][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBlockRef(r randyAgro, easy bool) *BlockRef {
	this := &BlockRef{}
	this.Volume = uint64(uint64(r.Uint32()))
	this.INode = uint64(uint64(r.Uint32()))
	this.Block = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedINodeRef(r randyAgro, easy bool) *INodeRef {
	this := &INodeRef{}
	this.Volume = uint64(uint64(r.Uint32()))
	this.INode = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyAgro interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneAgro(r randyAgro) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringAgro(r randyAgro) string {
	v12 := r.Intn(100)
	tmps := make([]rune, v12)
	for i := 0; i < v12; i++ {
		tmps[i] = randUTF8RuneAgro(r)
	}
	return string(tmps)
}
func randUnrecognizedAgro(r randyAgro, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldAgro(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldAgro(data []byte, r randyAgro, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateAgro(data, uint64(key))
		v13 := r.Int63()
		if r.Intn(2) == 0 {
			v13 *= -1
		}
		data = encodeVarintPopulateAgro(data, uint64(v13))
	case 1:
		data = encodeVarintPopulateAgro(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateAgro(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateAgro(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateAgro(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateAgro(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovAgro(uint64(m.Uid))
	}
	if m.Gid != 0 {
		n += 1 + sovAgro(uint64(m.Gid))
	}
	if m.Mode != 0 {
		n += 1 + sovAgro(uint64(m.Mode))
	}
	if m.Flags != 0 {
		n += 1 + sovAgro(uint64(m.Flags))
	}
	if m.Ctime != 0 {
		n += 1 + sovAgro(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovAgro(uint64(m.Mtime))
	}
	return n
}

func (m *INode) Size() (n int) {
	var l int
	_ = l
	if m.Volume != 0 {
		n += 1 + sovAgro(uint64(m.Volume))
	}
	if m.INode != 0 {
		n += 1 + sovAgro(uint64(m.INode))
	}
	if m.Chain != 0 {
		n += 1 + sovAgro(uint64(m.Chain))
	}
	if m.Filesize != 0 {
		n += 1 + sovAgro(uint64(m.Filesize))
	}
	if len(m.Filenames) > 0 {
		for _, s := range m.Filenames {
			l = len(s)
			n += 1 + l + sovAgro(uint64(l))
		}
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovAgro(uint64(l))
	}
	if len(m.Attrs) > 0 {
		for k, v := range m.Attrs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + len(v) + sovAgro(uint64(len(v)))
			n += mapEntrySize + 1 + sovAgro(uint64(mapEntrySize))
		}
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovAgro(uint64(l))
		}
	}
	return n
}

func (m *BlockLayer) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgro(uint64(m.Type))
	}
	if m.Content != nil {
		l = len(m.Content)
		if l > 0 {
			n += 1 + l + sovAgro(uint64(l))
		}
	}
	return n
}

func (m *Directory) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgro(uint64(l))
	}
	if len(m.Files) > 0 {
		for k, v := range m.Files {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + l + sovAgro(uint64(l))
			n += mapEntrySize + 1 + sovAgro(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Volume) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgro(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovAgro(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovAgro(uint64(m.Type))
	}
	if m.MaxBytes != 0 {
		n += 1 + sovAgro(uint64(m.MaxBytes))
	}
	return n
}

func (m *FileEntry) Size() (n int) {
	var l int
	_ = l
	if m.Chain != 0 {
		n += 1 + sovAgro(uint64(m.Chain))
	}
	l = len(m.Sympath)
	if l > 0 {
		n += 1 + l + sovAgro(uint64(l))
	}
	return n
}

func (m *FileChainSet) Size() (n int) {
	var l int
	_ = l
	if len(m.Chains) > 0 {
		for k, v := range m.Chains {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAgro(uint64(k)) + 1 + sovAgro(uint64(v))
			n += mapEntrySize + 1 + sovAgro(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PeerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.UUID)
	if l > 0 {
		n += 1 + l + sovAgro(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAgro(uint64(l))
	}
	if m.LastSeen != 0 {
		n += 1 + sovAgro(uint64(m.LastSeen))
	}
	if m.TotalBlocks != 0 {
		n += 1 + sovAgro(uint64(m.TotalBlocks))
	}
	if m.UsedBlocks != 0 {
		n += 1 + sovAgro(uint64(m.UsedBlocks))
	}
	if m.LastRebalanceFinish != 0 {
		n += 1 + sovAgro(uint64(m.LastRebalanceFinish))
	}
	if m.LastRebalanceBlocks != 0 {
		n += 1 + sovAgro(uint64(m.LastRebalanceBlocks))
	}
	if m.Rebalancing {
		n += 2
	}
	if m.TimedOut {
		n += 2
	}
	return n
}

func (m *Ring) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgro(uint64(m.Type))
	}
	if m.Version != 0 {
		n += 1 + sovAgro(uint64(m.Version))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovAgro(uint64(m.ReplicationFactor))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovAgro(uint64(l))
		}
	}
	if len(m.Attrs) > 0 {
		for k, v := range m.Attrs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + len(v) + sovAgro(uint64(len(v)))
			n += mapEntrySize + 1 + sovAgro(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BlockRef) Size() (n int) {
	var l int
	_ = l
	if m.Volume != 0 {
		n += 1 + sovAgro(uint64(m.Volume))
	}
	if m.INode != 0 {
		n += 1 + sovAgro(uint64(m.INode))
	}
	if m.Block != 0 {
		n += 1 + sovAgro(uint64(m.Block))
	}
	return n
}

func (m *INodeRef) Size() (n int) {
	var l int
	_ = l
	if m.Volume != 0 {
		n += 1 + sovAgro(uint64(m.Volume))
	}
	if m.INode != 0 {
		n += 1 + sovAgro(uint64(m.INode))
	}
	return n
}

func sovAgro(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAgro(x uint64) (n int) {
	return sovAgro(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Uid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Gid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Mode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ctime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Mtime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *INode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: INode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: INode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Volume |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field INode", wireType)
			}
			m.INode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.INode |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			m.Chain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Chain |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filesize", wireType)
			}
			m.Filesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Filesize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filenames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filenames = append(m.Filenames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &Metadata{}
			}
			if err := m.Permissions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgro
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthAgro
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.Attrs == nil {
				m.Attrs = make(map[string]string)
			}
			m.Attrs[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BlockLayer{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockLayer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], data[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Directory) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Directory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Directory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgro
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthAgro
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthAgro
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &FileEntry{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Files == nil {
				m.Files = make(map[string]*FileEntry)
			}
			m.Files[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Volume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Volume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (Volume_VolumeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBytes", wireType)
			}
			m.MaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			m.Chain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Chain |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sympath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sympath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileChainSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileChainSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileChainSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Chains == nil {
				m.Chains = make(map[uint64]uint64)
			}
			m.Chains[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UUID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			m.LastSeen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastSeen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlocks", wireType)
			}
			m.TotalBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalBlocks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBlocks", wireType)
			}
			m.UsedBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UsedBlocks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRebalanceFinish", wireType)
			}
			m.LastRebalanceFinish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastRebalanceFinish |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRebalanceBlocks", wireType)
			}
			m.LastRebalanceBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastRebalanceBlocks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebalancing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rebalancing = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimedOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimedOut = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ring) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReplicationFactor |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &PeerInfo{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgro
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthAgro
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Attrs == nil {
				m.Attrs = make(map[string][]byte)
			}
			m.Attrs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRef) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Volume |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field INode", wireType)
			}
			m.INode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.INode |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			m.Block = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Block |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *INodeRef) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: INodeRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: INodeRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Volume |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field INode", wireType)
			}
			m.INode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.INode |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgro(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAgro
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAgro
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAgro(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAgro = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgro   = fmt.Errorf("proto: integer overflow")
)
